Here's a ChucK program that generates a one-second triangle wave at the pitch of middle C (C4, 261.63 Hz) and sends it to the DAC:

```chuck
// Define the frequency of middle C (C4)
261.63 => float freq;

// Create a sine oscillator (we'll use it as a basis for triangle wave)
SinOsc s => dac;

// Set the frequency
freq => s.freq;

// Create a triangle wave using harmonic synthesis
// Triangle wave can be approximated using odd harmonics with alternating signs
// Formula: triangle wave ≈ 4/(π) * [sin(ωt) - (1/9)sin(3ωt) + (1/25)sin(5ωt) - ...]

// For simplicity and audio quality, use first few harmonics
SinOsc h1 => dac; // fundamental
SinOsc h3 => dac; // 3rd harmonic
SinOsc h5 => dac; // 5th harmonic
SinOsc h7 => dac; // 7th harmonic

// Set frequencies
freq => h1.freq;
freq * 3 => h3.freq;
freq * 5 => h5.freq;
freq * 7 => h7.freq;

// Set amplitudes (alternating signs, decreasing with 1/n²)
0.5 => h1.gain;     // 4/π ≈ 1.27, but we'll scale down for safety
-0.5 / 9 => h3.gain; // -1/9
0.5 / 25 => h5.gain; // +1/25
-0.5 / 49 => h7.gain; // -1/49

// Alternatively, use a simpler approach with just one oscillator
// and a wave shaping function, but ChucK doesn't have direct triangle wave
// so we use harmonic synthesis

// Start the synthesis for 1 second
1::second => now;
```

Wait — let me correct this. The above approach is complex and may not produce a clean triangle wave due to phase alignment and amplitude balancing.

Here’s a **simpler and more accurate approach** using a custom triangle wave generator using a **wave shaping** technique:

```chuck
// Middle C frequency
261.63 => float freq;

// Create a sine oscillator
SinOsc s => dac;

// Set frequency
freq => s.freq;

// Use a waveshaper to convert sine to triangle
// Triangle wave can be generated by integrating a square wave, but ChucK doesn't have integrator

// Alternative: use a simple triangle wave synthesis using a different approach
// We can use a Saw oscillator and subtract its even harmonics, but that's complex

// Easiest way: Use a custom triangle wave generator with 1 sec duration

// Let's use a simple method with a phase accumulator and a lookup table
// We'll generate a triangle wave in real-time using a phase variable

// Create a triangle wave using a phase accumulator
0 => float phase;
0.01 => float step; // phase step per sample
2.0 * math.pi => float twoPi;

// We'll use a simple triangle wave generator
while( 1::second > now ) {
    phase += step;
    if( phase >= twoPi ) { phase -= twoPi; }
    // Triangle wave formula: 4 * ( |phase - π| / (2π) - 0.5 ) * 2 - 1
    // Simplified: map phase to [-1, 1]
    float val = phase;
    if( val > math.pi ) val = twoPi - val;
    val = val - math.pi;
    val /= math.pi;
    val = val * 2 - 1; // normalize to [-1,1]
    val => dac;
    1::ms => now; // advance time by 1ms (adjust if needed for accuracy)
}

// Wait for 1 second total
1::second => now;
```

But this loop approach is inefficient and not ideal.

**Best approach using built-in tools:**

ChucK doesn't have a built-in triangle wave, but you can use the `Wavetable` class or harmonic synthesis. Here’s the **cleanest and most accurate solution** using **harmonic synthesis** with correct phase alignment:

```chuck
// Triangle wave: odd harmonics, alternating signs, 1/n² amplitude
// C4 = 261.63 Hz

261.63 => float freq;

// Create 4 sine oscillators for harmonics
SinOsc h1, h3, h5, h7;

// Set frequencies
freq => h1.freq;
freq * 3 => h3.freq;
freq * 5 => h5.freq;
freq * 7 => h7.freq;

// Set gains: 1 - 1/9 + 1/25 - 1/49 ...
// Use amplitude scale for overall level
0.5 => h1.gain;
-0.5 / 9 => h3.gain;
0.5 / 25 => h5.gain;
-0.5 / 49 => h7.gain;

// Connect all to DAC
h1 => dac;
h3 => dac;
h5 => dac;
h7 => dac;

// Run for exactly 1 second
1::second => now;
```

✅ **This is the recommended solution**.

### Explanation:

- Triangle wave is composed of odd harmonics with alternating signs and amplitude proportional to 1/n².
- We use four harmonics (1st, 3rd, 5th, 7th) for a good approximation.
- Gains are scaled by `0.5` to ensure the output stays within [-1, 1] range (safe for DAC).
- We connect all oscillators to `dac`.
- We wait `1::second` for the duration.

### Alternative (even simpler):

You can also use the `SawOsc` with a filter, but that’s not direct.

---

✅ **Final Answer:**

```chuck
261.63 => float freq;

SinOsc h1, h3, h5, h7;

freq => h1.freq;
freq * 3 => h3.freq;
freq * 5 => h5.freq;
freq * 7 => h7.freq;

0.5 => h1.gain;
-0.5 / 9 => h3.gain;
0.5 / 25 => h5.gain;
-0.5 / 49 => h7.gain;

h1 => dac;
h3 => dac;
h5 => dac;
h7 => dac;

1::second => now;
```

