Thinking...
We are going to:
 1. Read offices.csv into a data.table called 'offices'
 2. Read homes.csv into a data.table called 'homes'
 3. Join the two tables on 'employee_id' using the intersect (i.e., only keep rows where employee_id is in both)
 4. Write the result to 'result.csv'

 Steps:
 - Use fread from data.table to read the CSV files (as they are text files)
 - We assume the columns are named exactly as given: 'employee_id', 'work_address' for offices and 'employee_id', 'home_address' for homes.
 - For the join, we want to keep only the common employee_ids. We can do a left join but then filter for the common ones? 
   Alternatively, we can use `merge` but with data.table we can use `merge` or `i` for join.

 However, note: The requirement is to have only rows where employee_id exists in both. So we can do:

   result = merge(offices, homes, by = 'employee_id', all = FALSE)

 But note: data.table's merge is for merging two tables. Alternatively, we can use:

   result = offices[ homes, on = "employee_id", nomatch = 0 ]

 However, the problem says: "only have a row if the employee_id exists in both". So we want to keep only the matching rows.

 Since the problem says "only have a row if the employee_id exists in both", we can do:

   result = offices[ , .(employee_id, work_address, home_address), on = "employee_id"][homes]

 But that is not the most efficient and also we are only getting one table. Alternatively, we can do:

   result = merge(offices, homes, by = "employee_id", all = FALSE)

 But note: the data.table merge function can do this.

 However, the problem says: "Produce a joined data.table 'result' on column 'employee_id'. The output table should have text columns 'employee_id', 'work_address' and 'home_address' and only have a row if the 'employee_id' exists in both input tables."

 So we want to do an inner join (keep only the rows that are present in both).

 Since we are using data.table, we can do:

   result = merge(offices, homes, by = "employee_id", all = FALSE)

 But note: the merge function in data.table by default does an inner join (if all=FALSE). However, the merge function in data.table is for two data.tables and it does an inner join.

 Alternatively, we can do:

   result = offices[ homes, on = "employee_id", nomatch = 0 ]

 But the problem says to write the result in a specific format.

 However, note: the problem says "Write the joined table to 'result.csv'".

 Let's break down:

 Step 1: Read offices.csv
   offices = fread("offices.csv")

 Step 2: Read homes.csv
   homes = fread("homes.csv")

 Step 3: Join
   We want only rows where employee_id is in both. So we do:

   result = merge(offices, homes, by = "employee_id")

   But note: the merge function by default does an inner join (which is what we want). However, the documentation says that when all=FALSE, it does an inner join. But by default, all is set to FALSE for merge? Actually, in data.table, the merge function:

   merge(x, y, by, all = FALSE, ...)

   So by default, it does inner join.

   However, we can also use:

   result = offices[homes, on = "employee_id"]

   But that returns a table where the rows from offices are matched to homes. However, if we want to get the columns from both, we have to make sure we have all the columns we want.

   But note: the problem says to have columns: 'employee_id', 'work_address', 'home_address'

   The merge function by default will keep all the columns from both tables? But we only want these three.

   Actually, the merge function will return the columns of the first table and then the columns of the second table that are not in the first. However, we are merging on 'employee_id', so the other columns are from both.

   But we only want three columns. We can then select the columns we need.

   Alternatively, we can do:

   result = merge(offices, homes, by = "employee_id")
   result = result[, c("employee_id", "work_address", "home_address")]

   However, note: the first table (offices) has columns: 'employee_id', 'work_address' (and possibly others? but the problem says two text columns). Similarly, homes has two text columns: 'employee_id', 'home_address'. So the merge will have:

   - employee_id (from both, so duplicate? but they are the same column)
   - work_address (from offices)
   - home_address (from homes)

   So the merge table will have three columns.

   Therefore, we don't need to select if there are no other columns? But the problem says the input tables have only two text columns.

   So we can simply:

   result = merge(offices, homes, by = "employee_id")

   However, note: the problem says the input tables have two text columns. So the merge will have:

      employee_id (from offices) and then the columns from homes: home_address.

   But wait, the merge function in data.table for inner join returns the columns of the first table and then the columns of the second table that are not in the first. However, since the keys are the same, we get:

      employee_id (from offices) and then home_address (from homes) and also work_address (from offices) but wait, no.

   Actually, the merge function by default will create a table that has the columns of the first table and then the columns of the second table that are not in the first. But here, the first table has 'employee_id' and 'work_address'. The second table has 'employee_id' and 'home_address'. So the merge will have:

      employee_id (which is in both) -> will be duplicated? Actually, the merge function in data.table does:

        It will have the columns from the first table, and then the columns from the second table that are not in the first (with the same name? or with a suffix?).

        But note: the documentation says that if a column name is duplicated, it will not be duplicated. Actually, the merge function in data.table by default does not duplicate column names.

        The behavior is: it will return the columns of the first data.table, and then the columns of the second data.table that are not in the first.

        However, in our case, the second table has a column 'home_address' which is not in the first, so it will be included. And the first table has 'work_address' which is not in the second.

        But wait: the merge function in data.table does not actually include the duplicate key? Actually, the key is used for merging and then removed? Or kept?

        Actually, the merge function in data.table returns a table with the columns of both tables, but the key column is kept in both? Actually, no: the key is the merge column and it's the same in both. So it will have one copy of the key? Or two?

        According to the documentation: the output table will have the columns of the first data.table, and then the columns of the second data.table that are not in the first. So:

          First table: employee_id, work_address
          Second table: employee_id, home_address

        After merge, we get: employee_id, work_address, home_address.

        So the merge result will have exactly the three columns we want.

   Therefore, we can do:

      result = merge(offices, homes, by = "employee_id")

   And then write it.

   However, note: the problem says the input tables have two text columns. So there are no extra columns.

   But what if there are duplicate names? We don't have any other columns.

   Alternatively, we can use:

      result = offices[homes, on = "employee_id", nomatch = 0]

   This is also an inner join. And it will produce a table with columns:

        employee_id (from offices), work_address (from offices), home_address (from homes)

   So same as above.

   Which one is more efficient? The `merge` function is implemented in C and is efficient. But the `i` method is also efficient.

   However, the problem says to use data.table. Both are acceptable.

   Let me choose `merge` because it's straightforward.

   But note: the problem says to write the table to a CSV.

   Steps:

      # Read the CSV files
      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")

      # Merge
      result <- merge(offices, homes, by = "employee_id")

      # Write to result.csv
      fwrite(result, "result.csv")

   However, note: the problem says the tables have text columns. The read by fread will treat them as character by default? Yes, unless the data is numeric.

   But the problem says "text columns", so we assume they are character.

   But note: the data might have commas? Then we would have to use `sep` or `quote`? But the problem doesn't specify.

   Since the problem says "text columns", and we are reading from CSV, we assume that the CSV is formatted with commas and quotes appropriately.

   We are using `fread` which handles that by default.

   However, the problem doesn't specify the format, so we assume the standard.

   Let's write the program accordingly.

   But note: the problem says "Write the joined table to 'result.csv'".

   We'll use `fwrite` to write the result.

   However, note: the problem doesn't specify the encoding or other parameters, so we write without extra parameters.

   Code:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   But wait: what if the merge produces a table with more than three columns? We are only getting three.

   However, the problem states the input tables have two text columns. So the merge will only have three.

   However, what if the input tables have more columns? The problem says: "two text columns". So we are safe.

   But the problem says: "This table has two text columns". So we assume only these two.

   However, the problem says "This table" meaning offices has two and homes has two.

   So the merge will have:

        offices: employee_id, work_address
        homes: employee_id, home_address

   Merge: employee_id, work_address, home_address

   Exactly three.

   But note: what if there is a column named differently? The problem says the same column name 'employee_id'.

   So it's safe.

   However, the problem says: "The output table should have text columns 'employee_id', 'work_address' and 'home_address'"

   So we are good.

   But note: the problem says "only have a row if the 'employee_id' exists in both input tables". The merge by default does inner join (which is what we want).

   Therefore, the code:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   However, there is an alternative with `data.table`:

      result <- offices[homes, on = "employee_id", nomatch = 0]

   This is also an inner join and produces the same table.

   But the problem says "produce a joined data.table", so either is acceptable.

   I'll choose the `merge` version because it is explicit.

   However, note: the problem says "using data.table", and both are data.table methods.

   Let me run a small test:

      offices = data.table(employee_id = c("1", "2"), work_address = c("A", "B"))
      homes = data.table(employee_id = c("1", "2"), home_address = c("X", "Y"))

      merge(offices, homes, by = "employee_id") 
      # gives:
      #   employee_id work_address home_address
      #   1           1            A            X
      #   2           2            B            Y

   Exactly what we want.

   But note: what if the data is not in the same order? The merge will keep the order of the first table (offices) by default? Actually, the merge function in data.table does not guarantee order, but the problem does not require order.

   However, the problem doesn't specify order, so we don't care.

   Therefore, the program:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   But note: the problem says the columns are text. We assume that the data in the CSV is text (so we don't need to convert to numeric or anything).

   However, if the employee_id is numeric, then the merge would work? But the problem says "text columns", so we assume they are character.

   But note: the problem says "text columns", so they are character.

   Therefore, we are safe.

   Let me write the code accordingly.

   However, note: the problem says the file is called 'offices.csv' and 'homes.csv'. We assume they are in the working directory.

   We don't have to handle errors, because the problem doesn't specify.

   Code:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   But wait: what if the column name is not exactly "employee_id" in the input? The problem says the column is named 'employee_id'. So we assume it is.

   However, if there is a typo, the problem doesn't say to handle that.

   So we assume the column names are exactly as specified.

   Therefore, the code is as above.

   However, note: the problem says "text columns", but what if there are non-text? The problem says text, so we assume string.

   We write the code accordingly.

   But note: the problem says "Write the joined table to 'result.csv'", so we use `fwrite` which by default writes without row names and with the same column order.

   This is acceptable.

   Final code:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   However, there is a potential issue: if the data tables are large, the merge function is efficient.

   We are using the standard data.table merge, which is efficient.

   But note: the problem does not specify performance constraints.

   This should be acceptable.

   Let me write it.

   But note: the problem says "do the following", so we write the code as described.

   However, I just thought: the problem says "Produce a joined data.table 'result' on column 'employee_id'". The merge function does exactly that.

   Therefore, we are done.

   However, what if there are duplicate employee_ids? The problem doesn't say. But the problem says "only have a row if the employee_id exists in both". So if an employee_id appears multiple times in one table and the same in the other, then it will appear multiple times in the result. That is correct because if one employee has multiple work addresses? But the problem says the input table has two columns and one row per employee? Not necessarily. The problem doesn't specify.

   However, the problem says: "the employee_id exists in both". So if the same employee_id appears twice in one table and once in the other, then the merge will produce two rows (for the two work addresses) as long as the home address is present for that employee_id? Actually, no: if the same employee_id appears twice in offices and once in homes, then the merge will produce two rows (because the homes table has only one home address for that employee_id? but if the homes table has one row for the employee_id, then the merge would match both work addresses to the same home address? But that is not the case because the homes table has one home address per employee_id? Actually, the homes table would have one row per employee_id? Or multiple?

   The problem does not specify. So we assume that the employee_id is the primary key in both tables? Or not necessarily.

   However, the requirement: only have a row if the employee_id exists in both. So if an employee_id appears multiple times in offices and the same employee_id appears at least once in homes, then all the rows for that employee_id in offices will be included (each with the home address from homes). But the problem says "exists in both", meaning at least one occurrence? Actually, the merge will keep all rows from offices that have an employee_id that exists in homes (which is the inner join). So if an employee_id appears multiple times in offices and once in homes, then we get as many rows as the offices table has for that employee_id? And the home address will be the same (from the homes table) for each.

   This is correct.

   Therefore, the code is as written.

   We output:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   However, note: the problem says the columns are text, but what if the employee_id is numeric? The problem says "text columns", so we assume they are string.

   But if they are numeric, then the merge would work as well? Because the employee_id is the same value. However, the problem says text, so we assume they are character.

   But to be safe, we can convert the columns to character? The problem doesn't require it.

   Since the problem says "text columns", we assume they are character. And the data.table will read them as character by default if the CSV has quotes or if the columns are not numeric.

   However, if the CSV does not have quotes and the columns are numeric, then they would be read as numeric. But the problem says text, so we assume they are in quotes.

   Alternatively, we can force:

      offices <- fread("offices.csv", colClasses = c("employee_id" = "character", "work_address" = "character"))
      homes <- fread("homes.csv", colClasses = c("employee_id" = "character", "home_address" = "character"))

   But the problem doesn't specify the format, so we don't need to. The problem says "text columns", meaning they are string.

   However, to be safe, we can convert to character if necessary? But the problem says text, so they are string.

   But the problem does not say how the CSV is written. So if the CSV writes the employee_id without quotes, and it's numeric, then fread would read it as numeric. But the problem says text columns, so we assume they are string.

   Since the problem states that the columns are text, we can assume the CSV is written in a way that they are read as character.

   Alternatively, we can use:

      offices <- fread("offices.csv", stringsAsFactors = FALSE)
      homes <- fread("homes.csv", stringsAsFactors = FALSE)

   Then they are character vectors.

   But the problem does not specify, so we can do without.

   However, to be safe, we'll assume that the data is read as character.

   The problem says "text columns", so we can assume they are character.

   Therefore, we don't need to convert.

   Final code:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   But note: the problem says the column names are exactly as given. So we are safe.

   Let's write the code accordingly.

   However, there is a caveat: if the file has a header, then `fread` by default assumes the first row is header. The problem does not specify, but typically CSVs have headers.

   So we assume the files have headers.

   If they don't, then we need to set `header = FALSE`, but the problem doesn't say.

   Since the problem says the columns are named, we assume the files have headers.

   Therefore, the code is as above.

   We output the code.

   But note: the problem says "Please write an R program using data.table"

   So we write:

      library(data.table)
      offices <- fread("offices.csv")
      homes <- fread("homes.csv")
      result <- merge(offices, homes, by = "employee_id")
      fwrite(result, "result.csv")

   However, the problem says "only have a row if the employee_id exists in both". The merge with `by = "employee_id"` does exactly that.

   Therefore, this is the solution.

   But note: what if there are multiple columns with the same name? The problem says each table has two text columns, and the only column that is common is 'employee_id'. So no problem.

   We are done.
...done thinking.

Here is the R program using `data.table` to accomplish the specified tasks:

```r
library(data.table)

# Read 'offices.csv' into a data.table
offices <- fread("offices.csv")

# Read 'homes.csv' into a data.table
homes <- fread("homes.csv")

# Inner join on 'employee_id' (only keep rows where employee_id exists in both)
result <- merge(offices, homes, by = "employee_id")

# Write the result to 'result.csv'
fwrite(result, "result.csv")
```

**Explanation:**

1. **Reading Files:**  
   - `fread()` from `data.table` efficiently reads CSV files with automatic column naming (assuming header rows are present, as specified by the problem).
   - `offices` contains `employee_id` and `work_address`.
   - `homes` contains `employee_id` and `home_address`.

2. **Join Operation:**  
   - `merge(offices, homes, by = "employee_id")` performs an **inner join** (only keeps rows where `employee_id` exists in both tables).
   - The result automatically includes all columns from both tables, but since:
     - `offices` has `employee_id` and `work_address`
     - `homes` has `employee_id` and `home_address`
   - The merged result contains exactly the required columns: `employee_id`, `work_address`, and `home_address`.

3. **Writing Output:**  
   - `fwrite()` writes the joined table to `result.csv` in CSV format, with no row names or extra formatting.

**Key Notes:**
- This solution assumes the input files have headers (column names as specified) and are comma-delimited.
- The `merge` function with `by = "employee_id"` ensures only matching `employee_id` values are retained.
- All operations are efficient for large datasets (a hallmark of `data.table`).

**Sample Workflow:**
- If `offices.csv` contains:
  ```
  employee_id,work_address
  e1,Address1
  e2,Address2
  ```
- And `homes.csv` contains:
  ```
  employee_id,home_address
  e1,Home1
  e2,Home2
  ```
- The output `result.csv` will be:
  ```
  employee_id,work_address,home_address
  e1,Address1,Home1
  e2,Address2,Home2
  ```

